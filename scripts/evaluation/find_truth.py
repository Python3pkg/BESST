'''
Created on Oct 12, 2013

@author: ksahlin
'''

import os
import argparse

class Alignment(object):
    def __init__(self, name, length, end_coordinate, downstream_gap, align_coverage, percent_id):
        self.name = name
        self.end_coordinate = end_coordinate
        self.length = length
        self.downstream_gap = downstream_gap
        self.align_coverage = align_coverage
        self.percent_id = percent_id
        self.links = []
    def add_link(self, name, gap):
        self.links.append((name, gap))


def AlignContigs(ref, query, out):
    outpath = os.path.join(out, 'truth.agf')
    #### Do nucmer alignment plus tiling of contigs onto genome###
    print "nucmer -mum -c 65 -p nucmer " + ref + ' ' + query
    os.popen("nucmer -mum -c 65 -p nucmer " + ref + ' ' + query)
    try:
        os.mkdir(out)
    except OSError:
        #directory is already created
        pass
    print "show-tiling nucmer.delta"
    os.popen("show-tiling -c -g -1 nucmer.delta > " + outpath)
    os.remove('nucmer.delta')
    return()

def get_true_edges(agf_file, out, max_distance):
    #### Create our out file from the .pgf file generated by nucmer ###
    outfile = open(os.path.join(out, 'possible_links.txt'), 'w')
    alignment_dict = {}

    for line in agf_file:
        if line[0] == '>':
            # new reference sequence
            for aln_object in alignment_dict:
                for name, gap in alignment_dict[aln_object].links:
                    print >> outfile, alignment_dict[aln_object].name + '\t' + name + '\t' + str(gap)
            alignment_dict = {}
            continue

        columns = line.split('\t')
        align_cov = float(columns[4])
        perc_id = float(columns[5])
        name = columns[7].strip()
        gap = int(columns[2].strip())
        length = int(columns[3])
        end_coordinate = int(columns[1])
        current_coordinate = int(columns[0])
        if float(align_cov) > 90 and float(perc_id) > 90:
            a = Alignment(name, length, end_coordinate, gap, align_cov, perc_id)

            for al_obj in alignment_dict:
                if current_coordinate - alignment_dict[al_obj].end_coordinate <= max_distance:
                    alignment_dict[al_obj].add_link(a.name, current_coordinate - alignment_dict[al_obj].end_coordinate - 1)

            alignment_dict[a.name] = a




    return()

if __name__ == '__main__':
    ##
    # Take care of input
    parser = argparse.ArgumentParser(description="Find correct placements for contigs on reference")
    parser.add_argument('ref', type=str, help='Path to reference genome (fasta) ')
    parser.add_argument('query', type=str, help='Path to contig file (fasta) ')
    parser.add_argument('out', type=str, help='Path to output location for files. ')
    parser.add_argument('max_edge_dist', type=int, help='Maximum distance for the library to span two contigs (reasonable: mu + 2*sigma). ')



    args = parser.parse_args()

    AlignContigs(args.ref, args.query, args.out)
    agf_file = open(os.path.join(args.out, 'truth.agf'), 'r')
    get_true_edges(agf_file, args.out, args.max_edge_dist)
